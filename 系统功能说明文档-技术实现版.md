# 多智能体RAG客服系统功能说明文档 - 技术实现版

## 1. 项目概述

本项目实现了一个基于多智能体（Multi-Agent）和检索增强生成（Retrieval-Augmented Generation, RAG）技术的客户支持系统。它利用 Python、LangChain 和 LangGraph 构建了一个能够处理各种旅行相关查询的对话式 AI，包括航班预订、租车、酒店预订和行程推荐。

系统采用模块化架构，主要由一个主助手（Primary Assistant）和多个专门处理特定任务的子助手（Specialized Assistants）组成。这种设计使得系统能够根据用户需求灵活地在不同助手间切换，同时通过敏感操作确认机制和新增的安全护栏机制保障用户数据安全和系统稳定运行。

## 2. 核心功能模块

### 2.1 主助手 (Primary Assistant)
- **功能**：作为用户交互的入口点，处理通用查询，并根据用户需求将任务委派给相应的专门助手。
- **工具**：
  - `DuckDuckGoSearchResults`：用于网络搜索。
  - `search_flights`：搜索航班信息。
  - `lookup_policy`：查询公司政策。
  - 委派工具（将任务转交给专门助手）：
    - `ToFlightBookingAssistant`：处理航班更新和取消。
    - `ToBookCarRental`：处理租车预订。
    - `ToHotelBookingAssistant`：处理酒店预订、修改和取消。
    - `ToBookExcursion`：处理行程推荐和其他活动预订。
    - `ToWooCommerceProducts`：处理 WooCommerce 产品搜索。
    - `ToWooCommerceOrders`：处理 WooCommerce 订单搜索（需要用户提供邮箱或姓名验证）。
    - `ToFormSubmission`：处理用户表单提交。
    - `ToBlogSearch`：处理博客文章搜索。

**代码实现说明：**
主助手在 <mcfile name="primary_assistant.py" path="customer_support_chat/app/services/assistants/primary_assistant.py"></mcfile> 中定义，使用 LangChain 的 ChatPromptTemplate 创建系统提示，并通过 llm.bind_tools() 绑定所有工具。委派工具使用 Pydantic BaseModel 定义，包含必要的字段描述。

**委派实现原理：**

委派机制是系统的核心设计，通过Pydantic模型定义委派工具，结合LangGraph的状态路由实现智能任务分发。具体原理如下：

### 1. 委派工具定义
委派工具使用Pydantic BaseModel定义，每个委派工具对应一个专门助手：

```python
class ToFlightBookingAssistant(BaseModel):
    """Transfers work to a specialized assistant to handle flight updates and cancellations."""
    request: str = Field(description="Any necessary follow-up questions the update flight assistant should clarify before proceeding.")
```

### 2. 工具绑定与路由
主助手通过`llm.bind_tools()`绑定所有委派工具，当用户请求需要专门处理时，主助手会调用相应的委派工具：

```python
primary_assistant_tools = [
    DuckDuckGoSearchResults(max_results=10),
    search_flights,
    lookup_policy,
    ToFlightBookingAssistant,  # 航班预订委派
    ToBookCarRental,          # 租车委派
    ToHotelBookingAssistant,   # 酒店委派
    ToBookExcursion,          # 旅行推荐委派
    ToWooCommerceProducts,     # 产品搜索委派
    ToWooCommerceOrders,       # 订单搜索委派
    ToFormSubmission,         # 表单提交委派
    ToBlogSearch,             # 博客搜索委派
]
```

### 3. 路由机制
当主助手调用委派工具后，`route_primary_assistant`函数根据工具名称路由到对应的专门助手：

```python
def route_primary_assistant(state: State):
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    if tool_calls:
        tool_name = tool_calls[0]["name"]
        if tool_name == ToFlightBookingAssistant.__name__:
            return "enter_update_flight"  # 路由到航班助手
        elif tool_name == ToBookCarRental.__name__:
            return "enter_book_car_rental"  # 路由到租车助手
        # ... 其他委派工具路由
    return "primary_assistant"
```

### 4. 入口节点创建
每个专门助手都有一个入口节点，负责初始化助手状态和上下文：

```python
def create_entry_node(assistant_name: str, new_dialog_state: str) -> Callable:
    def entry_node(state: State) -> dict:
        # 处理工具调用消息
        last_message = state["messages"][-1]
        tool_messages = []
        
        if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
            for tool_call in last_message.tool_calls:
                tool_messages.append(
                    ToolMessage(
                        content=(
                            f"The assistant is now the {assistant_name}. Reflect on the above conversation. "
                            f"The user's intent is unsatisfied. Use the provided tools to assist the user. "
                            "If the user changes their mind, call CompleteOrEscalate to return to primary assistant."
                        ),
                        tool_call_id=tool_call["id"],
                    )
                )
        return {"messages": tool_messages, "dialog_state": new_dialog_state}
    return entry_node
```

### 5. 状态管理
系统使用统一的State类管理对话状态，包含消息、用户信息和对话状态栈：

```python
class State(TypedDict):
    messages: Annotated[list[Any], operator.add]
    user_info: str
    dialog_state: Annotated[Optional[list[str]], update_dialog_stack]
```

### 6. 工具条件判断
LangGraph内置的`tools_condition`函数自动检测工具调用状态，决定下一步路由：
- 如果有工具调用，路由到工具执行节点
- 如果没有工具调用，路由到下一个助手节点
- 如果对话结束，返回END状态

### 7. 委派流程总结
1. **用户请求** → 主助手处理
2. **识别需求** → 主助手判断需要专门处理
3. **调用委派工具** → 生成委派工具调用
4. **路由检测** → `tools_condition`检测到工具调用
5. **专门助手路由** → `route_primary_assistant`根据工具名称路由
6. **入口节点初始化** → 创建专门助手上下文
7. **专门处理** → 专门助手使用专用工具完成任务
8. **返回主助手** → 通过CompleteOrEscalate工具或任务完成返回


### 2.2 航班预订助手 (Flight Booking Assistant)
- **功能**：专门处理航班更新和取消请求。
- **工具**：
  - **安全工具**：
    - `search_flights`：搜索航班。
    - `CompleteOrEscalate`：完成任务或升级到主助手。
  - **敏感工具**（需要用户确认）：
    - `update_ticket_to_new_flight`：更新机票到新航班。
    - `cancel_ticket`：取消机票。

**代码实现说明：**
航班助手在 <mcfile name="flight_booking_assistant.py" path="customer_support_chat/app/services/assistants/flight_booking_assistant.py"></mcfile> 中实现，使用专门的系统提示来处理航班更新任务。工具分为安全工具和敏感工具两组，通过不同的路由逻辑处理。

### 2.3 租车助手 (Car Rental Assistant)
- **功能**：专门处理租车预订、修改和取消。
- **工具**：
  - **安全工具**：
    - `search_car_rentals`：搜索可用车辆。
    - `CompleteOrEscalate`：完成任务或升级到主助手。
  - **敏感工具**（需要用户确认）：
    - `book_car_rental`：预订车辆。
    - `update_car_rental`：更新租车信息（如日期）。
    - `cancel_car_rental`：取消租车。

### 2.4 酒店预订助手 (Hotel Booking Assistant)
- **功能**：专门处理酒店预订、修改和取消。
- **工具**：
  - **安全工具**：
    - `search_hotels`：搜索可用酒店。
    - `CompleteOrEscalate`：完成任务或升级到主助手。
  - **敏感工具**（需要用户确认）：
    - `book_hotel`：预订酒店。
    - `update_hotel`：更新酒店预订（如日期）。
    - `cancel_hotel`：取消酒店预订。

### 2.5 行程推荐助手 (Excursion Assistant)
- **功能**：专门处理行程推荐和其他活动的预订、修改和取消。
- **工具**：
  - **安全工具**：
    - `search_trip_recommendations`：搜索行程推荐。
    - `CompleteOrEscalate`：完成任务或升级到主助手。
  - **敏感工具**（需要用户确认）：
    - `book_excursion`：预订行程。
    - `update_excursion`：更新行程详情。
    - `cancel_excursion`：取消行程。

### 2.6 WooCommerce 助手
- **功能**：专门处理与 WooCommerce 商店的交互。
- **工具**：
  - `search_products`：根据关键词搜索产品。
  - `search_orders`：根据邮箱、姓名或订单ID搜索订单（需要验证）。
  - `CompleteOrEscalate`：完成任务或升级到主助手。

### 2.7 表单提交助手 (Form Submission Assistant)
- **功能**：专门处理用户表单提交。
- **工具**：
  - `submit_form`：提交包含用户姓名、邮箱、主题等信息的表单。
  - `CompleteOrEscalate`：完成任务或升级到主助手。

### 2.8 博客搜索助手 (Blog Search Assistant)
- **功能**：专门处理博客文章搜索。
- **工具**：
  - `search_blog_posts`：根据关键词搜索博客文章。
  - `CompleteOrEscalate`：完成任务或升级到主助手。

## 3. 数据源与向量数据库

### 3.1 旅行数据库 (Travel Database)
- 使用 SQLite 数据库 (`travel2.sqlite`) 存储航班、预订、乘客等旅行相关数据。

### 3.2 Qdrant 向量数据库
- 使用 Qdrant 存储和查询旅行数据库内容的向量嵌入，以支持高效的语义搜索。

## 4. 系统架构与代码实现

### 4.1 助手基类设计
所有助手都继承自 <mcsymbol name="Assistant" filename="assistant_base.py" path="customer_support_chat/app/services/assistants/assistant_base.py" startline="18" type="class"></mcsymbol> 基类，该基类提供了统一的调用接口和错误处理机制：

```python
class Assistant:
    def __init__(self, runnable: Runnable):
        self.runnable = runnable

    def __call__(self, state: State, config: Optional[RunnableConfig] = None):
        while True:
            result = self.runnable.invoke(state, config)
            # 处理空响应和工具调用
            if not result.tool_calls and (not result.content or 
               isinstance(result.content, list) and not result.content[0].get("text")):
                messages = state["messages"] + [("user", "Respond with a real output.")]
                state = {**state, "messages": messages}
            else:
                break
        return {"messages": result}
```

### 4.2 工具实现模式
所有工具都使用 LangChain 的 `@tool` 装饰器定义，遵循统一的参数规范和错误处理：

```python
@tool
def search_flights(query: str, limit: int = 2) -> List[Dict]:
    """Search for flights based on a natural language query."""
    search_results = flights_vectordb.search(query, limit=limit)
    
    flights = []
    for result in search_results:
        payload = result.payload
        flights.append({
            "flight_id": payload["flight_id"],
            "flight_no": payload["flight_no"],
            "departure_airport": payload["departure_airport"],
            "arrival_airport": payload["arrival_airport"],
            "scheduled_departure": payload["scheduled_departure"],
            "scheduled_arrival": payload["scheduled_arrival"],
            "status": payload["status"],
            "aircraft_code": payload["aircraft_code"],
            "actual_departure": payload["actual_departure"],
            "actual_arrival": payload["actual_arrival"],
            "chunk": payload["content"],
            "similarity": result.score,
        })
    return flights
```

### 4.3 状态管理
系统状态在 <mcfile name="state.py" path="customer_support_chat/app/core/state.py"></mcfile> 中定义，使用 TypedDict 确保类型安全：

```python
class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]
    user_info: str
    dialog_state: Annotated[
        list[
            Literal[
                "assistant",
                "update_flight",
                "book_car_rental",
                "book_hotel",
                "book_excursion",
            ]
        ],
        update_dialog_stack,
    ]
```

### 4.4 工作流图构建
系统使用 LangGraph 构建工作流，在 <mcfile name="graph.py" path="customer_support_chat/app/graph.py"></mcfile> 中定义：

```python
# 初始化图
builder = StateGraph(State)

# 添加用户信息获取节点
builder.add_node("fetch_user_info", user_info)
builder.add_edge(START, "fetch_user_info")

# 添加安全检查节点
builder.add_node("guardrail_check", guardrail_check)
builder.add_edge("fetch_user_info", "guardrail_check")

# 添加航班助手相关节点
builder.add_node("enter_update_flight", create_entry_node("Flight Updates & Booking Assistant", "update_flight"))
builder.add_node("update_flight", flight_booking_assistant)
builder.add_edge("enter_update_flight", "update_flight")

# 添加工具节点
builder.add_node("update_flight_safe_tools", create_tool_node_with_fallback(update_flight_safe_tools))
builder.add_node("update_flight_sensitive_tools", create_tool_node_with_fallback(update_flight_sensitive_tools))

# 定义路由逻辑
def route_update_flight_tools(state: State) -> Literal["update_flight", "primary_assistant"]:
    return "primary_assistant" if should_route_to_primary(state) else "update_flight"
```

### 4.5 工具节点创建与错误处理
工具节点使用 <mcsymbol name="create_tool_node_with_fallback" filename="utils.py" path="customer_support_chat/app/services/utils.py" startline="135" type="function"></mcsymbol> 函数创建，包含错误处理机制：

```python
def create_tool_node_with_fallback(tools: list):
    from langchain_core.messages import ToolMessage
    from langchain_core.runnables import RunnableLambda
    from langgraph.prebuilt import ToolNode

    return ToolNode(tools).with_fallbacks(
        [RunnableLambda(handle_tool_error)], exception_key="error"
    )

# 错误处理函数
def handle_tool_error(state) -> dict:
    error = state.get("error")
    tool_calls = state["messages"][-1].tool_calls
    return {
        "messages": [
            {
                "type": "tool",
                "content": f"Error: {repr(error)}\nPlease fix your mistakes.",
                "tool_call_id": tc["id"],
            }
            for tc in tool_calls
        ]
    }
```

### 4.6 入口节点创建
助手入口节点使用 <mcsymbol name="create_entry_node" filename="utils.py" path="customer_support_chat/app/services/utils.py" startline="12" type="function"></mcsymbol> 函数创建：

```python
def create_entry_node(assistant_name: str, new_dialog_state: str) -> Callable:
    def entry_node(state: State) -> dict:
        # 处理所有工具调用
        last_message = state["messages"][-1]
        tool_messages = []
        
        if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
            for tool_call in last_message.tool_calls:
                tool_messages.append(
                    ToolMessage(
                        content=(
                            f"The assistant is now the {assistant_name}. Reflect on the above conversation between the host assistant and the user. "
                            f"The user's intent is unsatisfied. Use the provided tools to assist the user. Remember, you are {assistant_name}, "
                            "and the booking, update, or other action is not complete until after you have successfully invoked the appropriate tool. "
                            "If the user changes their mind or needs help for other tasks, call the CompleteOrEscalate function to let the primary host assistant take control. "
                            "Do not mention who you are—just act as the proxy for the assistant."
                        ),
                        tool_call_id=tool_call["id"],
                    )
                )
        else:
            # 回退处理
            tool_messages.append(
                ToolMessage(
                    content=(
                        f"The assistant is now the {assistant_name}. Reflect on the above conversation between the host assistant and the user. "
                        f"The user's intent is unsatisfied. Use the provided tools to assist the user. Remember, you are {assistant_name}, "
                        "and the booking, update, or other action is not complete until after you have successfully invoked the appropriate tool. "
                        "If the user changes their mind or needs help for other tasks, call the CompleteOrEscalate function to let the primary host assistant take control. "
                        "Do not mention who you are—just act as the proxy for the assistant."
                    ),
                    tool_call_id="fallback_tool_call_id",
                )
            )
        
        return {
            "messages": tool_messages,
            "dialog_state": new_dialog_state,
        }
    return entry_node
```

### 4.7 敏感操作确认机制
系统通过检查工具调用类型来实现敏感操作确认：

```python
def route_update_flight(state: State) -> Literal[
    "update_flight_safe_tools",
    "update_flight_sensitive_tools",
    "primary_assistant",
    "__end__",
]:
    route = tools_condition(state)
    if route == END:
        return END
    tool_calls = state["messages"][-1].tool_calls
    safe_toolnames = [t.name for t in update_flight_safe_tools]
    if all(tc["name"] in safe_toolnames for tc in tool_calls):
        return "update_flight_safe_tools"
    return "update_flight_sensitive_tools"
```

## 5. 关键设计模式

### 5.1 策略模式 (Strategy Pattern)
助手基类 <mcsymbol name="Assistant" filename="assistant_base.py" path="customer_support_chat/app/services/assistants/assistant_base.py" startline="18" type="class"></mcsymbol> 实现了策略模式，每个具体助手提供不同的 runnable 实现。

### 5.2 责任链模式 (Chain of Responsibility)
主助手通过委派工具将任务传递给专门助手，形成责任链：

```python
class ToFlightBookingAssistant(BaseModel):
    """Transfers work to a specialized assistant to handle flight updates and cancellations."""
    request: str = Field(description="Any necessary follow-up questions the update flight assistant should clarify before proceeding.")
```

### 5.3 工厂方法模式 (Factory Method)
工具节点创建使用工厂方法：

```python
def create_tool_node_with_fallback(tools):
    """Create a tool node with fallback handling for tool execution errors."""
    # 实现细节...
```

## 6. 开发指南

### 6.1 添加新助手
1. 在 <mcfolder name="assistants" path="customer_support_chat/app/services/assistants"></mcfolder> 目录下创建新的助手文件
2. 定义助手的系统提示和工具列表
3. 在 <mcfile name="__init__.py" path="customer_support_chat/app/services/assistants/__init__.py"></mcfile> 中导出新助手
4. 在 <mcfile name="graph.py" path="customer_support_chat/app/graph.py"></mcfile> 中添加相应的图节点和路由逻辑

### 6.2 添加新工具
1. 在 <mcfolder name="tools" path="customer_support_chat/app/services/tools"></mcfolder> 目录下创建新的工具文件
2. 使用 `@tool` 装饰器定义工具函数
3. 在 <mcfile name="__init__.py" path="customer_support_chat/app/services/tools/__init__.py"></mcfile> 中导出新工具
4. 在相应的助手文件中导入并使用新工具

### 6.3 调试与监控
系统集成了 LangSmith 进行可观察性监控：
- 跟踪请求生命周期
- 监控工具使用情况
- 记录代理响应和错误
- 性能分析和调试

## 7. 系统使用方法

### 7.1 启动系统
1. 确保已安装所有依赖项：`poetry install`
2. 启动 Qdrant 向量数据库：`docker compose up qdrant -d`
3. 运行客户支持聊天系统：`poetry run python ./customer_support_chat/app/main.py`

### 7.2 与系统交互
- 启动后，系统会提示用户输入问题。
- 用户可以询问航班信息、预订服务、查询政策等。
- 系统会自动根据查询内容委派给相应的助手处理。
- 对于涉及修改、取消等敏感操作，系统会暂停并请求用户确认。

## 8. 安全与确认机制

系统包含三层安全机制来保障用户数据安全和系统稳定运行：

1.  **敏感操作确认机制**：系统对所有可能修改用户数据的操作（如更新/取消航班、预订/取消酒店等）都标记为"敏感工具"。当这些工具被调用时，系统会自动暂停工作流，并明确提示用户进行确认，只有在用户同意后才会继续执行操作。

2.  **安全护栏机制**：系统在处理用户输入前，会通过专门的AI代理进行安全检查。
    *   **越狱防护**：检测用户是否试图绕过系统指令或进行越狱攻击（如询问系统提示词、注入恶意代码等）。如果检测到越狱行为，系统将拒绝响应并提示用户。
    *   **相关性检查**：检测用户的最新消息是否与客服系统的业务范围（航班、租车、酒店、电商、表单、博客等）高度相关。对于不相关的输入，系统会记录日志或发出警告（根据具体策略处理）。

3.  **人工审核机制 (GoHumanLoop)**：对于所有标记为"敏感工具"的操作，在用户确认后，系统还会通过 GoHumanLoop 框架将操作请求发送给系统管理员进行最终审核。管理员可以通过飞书等平台接收审核通知，并决定是否批准该操作。只有在管理员批准后，操作才会真正执行，进一步提升了系统的安全性。

**代码实现说明：**

安全护栏功能在 `customer_support_chat/app/services/guardrails/` 模块中实现。

### 1. 安全检查代理定义
在 `guardrail_agents.py` 文件中，我们定义了两个独立的AI代理：

```python
# 越狱防护代理
jailbreak_guardrail_agent = ChatOpenAI(
    model="gpt-4o-mini",
    openai_api_key=settings.OPENAI_API_KEY,
    temperature=0, # 确保输出稳定
).with_structured_output(JailbreakOutput)

# 相关性检查代理
relevance_guardrail_agent = ChatOpenAI(
    model="gpt-4o-mini",
    openai_api_key=settings.OPENAI_API_KEY,
    temperature=0, # 确保输出稳定
).with_structured_output(RelevanceOutput)
```

### 2. 安全检查节点实现
在 `graph.py` 文件中，我们添加了一个名为 `guardrail_check` 的新节点，该节点会在主助手处理用户请求之前执行安全检查：

```python
def guardrail_check(state: State, config: RunnableConfig):
    """Node to check user input for safety and relevance."""
    # 获取最新的用户消息
    user_messages = [msg for msg in state["messages"] if isinstance(msg, HumanMessage)]
    if not user_messages:
        logger.warning("No user message found for guardrail check. Allowing.")
        return {
            "messages": [HumanMessage(content="No user input to check. Please provide a query.")]
        }
    
    latest_user_message = user_messages[-1]
    user_input = latest_user_message.content
    
    logger.info(f"🛡️ Checking safety and relevance for user input: '{user_input}'")
    
    # 1. 检查越狱行为
    jailbreak_prompt = f"{jailbreak_guardrail_agent_instructions}

User Input: {user_input}"
    jailbreak_result = jailbreak_guardrail_agent.invoke(jailbreak_prompt)
    
    if not jailbreak_result.is_safe:
        logger.warning(f"🚨 Jailbreak attempt detected: {jailbreak_result.reasoning}")
        # 如果检测到越狱行为，直接返回拒绝信息并结束对话
        return {
            "messages": [HumanMessage(content=f"I cannot assist with that request. Reason: {jailbreak_result.reasoning}")]
        }

    # 2. 检查相关性
    relevance_prompt = f"{relevance_guardrail_agent_instructions}

User Input: {user_input}"
    relevance_result = relevance_guardrail_agent.invoke(relevance_prompt)
    
    if not relevance_result.is_relevant:
        logger.warning(f"⚠️ Irrelevant input detected: {relevance_result.reasoning}")
        # 对于不相关输入，可以选择记录日志或返回提示信息
        
    # 如果两项检查都通过，则继续正常流程
    logger.info("✅ Input passed safety and relevance checks.")
    return {"messages": []} # 无新消息添加，继续流程
```

### 3. 工作流集成
在 `graph.py` 中，我们将安全检查节点集成到主工作流中，确保它在获取用户信息后、主助手处理前执行：

```python
# 添加安全检查节点
builder.add_node("guardrail_check", guardrail_check)

# 定义工作流边
builder.add_edge(START, "fetch_user_info")
builder.add_edge("fetch_user_info", "guardrail_check")
# 安全检查通过后，连接到主助手
builder.add_edge("guardrail_check", "primary_assistant")
```

### 4. 人工审核机制实现
人工审核功能通过 GoHumanLoop 框架实现。在 `customer_support_chat/app/core/humanloop_manager.py` 中初始化了 GoHumanLoop 管理器和适配器：

```python
# 创建 GoHumanLoopManager 实例
humanloop_manager = DefaultHumanLoopManager(
    APIProvider(
        name="ApiProvider",
        api_base_url="http://127.0.0.1:9800/api", # 换成自己飞书应用的URL
        api_key=get_secret_from_env("GOHUMANLOOP_API_KEY"),
        default_platform="feishu"
    )
)
# 创建 LangGraphAdapter 实例
humanloop_adapter = HumanloopAdapter(
    manager=humanloop_manager,
    default_timeout=300,  # 默认超时时间为5分钟
)
```

所有需要人工审核的敏感工具（如 `update_ticket_to_new_flight`, `cancel_ticket`, `book_hotel` 等）都会使用 `@humanloop_adapter.require_approval(execute_on_reject=False)` 装饰器进行装饰。当这些工具被调用时，系统会自动暂停执行，并通过 GoHumanLoop 将审核请求发送给管理员：

```python
@tool
@humanloop_adapter.require_approval(execute_on_reject=False)
async def update_ticket_to_new_flight(
    ticket_no: str, new_flight_id: int, *, config: RunnableConfig, approval_result=None
) -> str:
    """Update the user's ticket to a new valid flight."""
    # 如果审批被拒绝，此函数体不会执行。
    # 如果审批通过，approval_result 将包含审批详情。
    # ... (工具的具体实现)
```

通过以上实现，系统在处理每个用户请求时都会先进行严格的安全检查，并对所有敏感操作进行双重确认（用户确认 + 管理员审核），从而有效防止恶意攻击、无关对话和未经授权的数据修改，全面提升了系统的安全性。

## 9. 性能优化建议

1. **向量搜索优化**：调整 Qdrant 的搜索参数和索引配置
2. **数据库连接池**：使用连接池管理数据库连接
3. **缓存策略**：对频繁查询的结果实施缓存
4. **异步处理**：对耗时操作使用异步处理
5. **监控告警**：设置性能监控和自动告警机制

## 10. 项目结构与依赖管理

### 10.1 项目结构
```
customer_support_chat/
├── app/
│   ├── core/                 # 核心模块
│   │   ├── settings.py       # 配置管理
│   │   ├── state.py          # 状态定义
│   │   └── logger.py         # 日志配置
│   ├── services/
│   │   ├── assistants/       # 助手实现
│   │   │   ├── assistant_base.py
│   │   │   ├── primary_assistant.py
│   │   │   ├── flight_booking_assistant.py
│   │   │   └── ...
│   │   └── tools/           # 工具实现
│   │       ├── flights.py
│   │       ├── hotels.py
│   │       ├── cars.py
│   │       └── ...
│   ├── graph.py             # 工作流图定义
│   └── main.py              # 主程序入口
└── data/                    # 数据文件
```

### 10.2 依赖管理
项目使用 Poetry 进行依赖管理，主要依赖包括：

```toml
[tool.poetry.dependencies]
langgraph = "^0.2.19"          # 工作流图框架
langchain-openai = "^0.1.23"    # OpenAI 集成
langchain-community = "^0.2.16" # 社区工具
qdrant-client = "^1.11.1"       # 向量数据库客户端
pandas = "^2.2.2"              # 数据处理
fastapi = "^0.116.1"           # Web 框架
uvicorn = "^0.35.0"            # ASGI 服务器
```

### 10.3 环境配置
系统配置通过环境变量管理，在 <mcfile name="settings.py" path="customer_support_chat/app/core/settings.py"></mcfile> 中定义：

```python
class Config:
    OPENAI_API_KEY: str = environ.get("OPENAI_API_KEY", "")
    OPENAI_BASE_URL: str = environ.get("OPENAI_BASE_URL", "")
    OPENAI_MODEL: str = environ.get("OPENAI_MODEL", "gpt-3.5-turbo")
    MAX_TOKENS: int = int(environ.get("MAX_TOKENS", "1000"))
    SQLITE_DB_PATH: str = environ.get("SQLITE_DB_PATH", "./customer_support_chat/data/travel2.sqlite")
    QDRANT_URL: str = environ.get("QDRANT_URL", "http://localhost:6333")
    # WooCommerce 和表单提交API配置
    WOOCOMMERCE_CONSUMER_KEY: str = environ.get("WOOCOMMERCE_CONSUMER_KEY", "")
    WOOCOMMERCE_CONSUMER_SECRET: str = environ.get("WOOCOMMERCE_CONSUMER_SECRET", "")
    WOOCOMMERCE_API_URL: str = environ.get("WOOCOMMERCE_API_URL", "")
```

## 11. 开发与部署指南

### 11.1 开发环境设置
1. 安装 Poetry：`pip install poetry`
2. 安装依赖：`poetry install`
3. 配置环境变量：复制 `.env.example` 为 `.env` 并填写实际值
4. 启动 Qdrant：`docker compose up qdrant -d`
5. 运行系统：`poetry run python ./customer_support_chat/app/main.py`

### 11.2 测试与调试
- 使用 LangSmith 进行请求跟踪和调试
- 设置 `LOG_LEVEL=DEBUG` 查看详细日志
- 使用 IPython 进行交互式调试

### 11.3 生产部署
1. 使用 Docker 容器化部署
2. 配置环境变量用于生产环境
3. 设置适当的日志级别和监控
4. 配置反向代理和SSL证书

## 12. 扩展性考虑

系统设计具有良好的扩展性：
- 模块化架构便于添加新功能模块
- 统一的助手接口便于集成新的AI模型
- 标准化的工具定义便于添加新的业务能力
- 灵活的路由机制支持复杂的业务流程
- 配置驱动的设计便于环境适配
- 完善的错误处理机制保障系统稳定性
- 新增的安全护栏机制和人工审核机制为系统提供了更强的安全性和可控性，同时也为未来增加更多类型的检查（如内容过滤、情感分析等）和更复杂的审批流程提供了可扩展的基础。